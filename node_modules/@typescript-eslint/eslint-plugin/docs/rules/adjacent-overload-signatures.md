<<<<<<< HEAD
<<<<<<< HEAD
---
description: 'Require that function overload signatures be consecutive.'
---

> 🛑 This file is source code, not the primary documentation location! 🛑
>
> See **https://typescript-eslint.io/rules/adjacent-overload-signatures** for documentation.

Function overload signatures represent multiple ways a function can be called, potentially with different return types.
It's typical for an interface or type alias describing a function to place all overload signatures next to each other.
If Signatures placed elsewhere in the type are easier to be missed by future developers reading the code.

## Examples

<!--tabs-->

### ❌ Incorrect
=======
=======
>>>>>>> 84b8e337c (figuring out lint)
# Require that member overloads be consecutive (`adjacent-overload-signatures`)

Grouping overloaded members together can improve readability of the code.

## Rule Details

This rule aims to standardize the way overloaded members are organized.

The following patterns are considered warnings:
<<<<<<< HEAD
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
---
description: 'Require that function overload signatures be consecutive.'
---

> 🛑 This file is source code, not the primary documentation location! 🛑
>
> See **https://typescript-eslint.io/rules/adjacent-overload-signatures** for documentation.

Function overload signatures represent multiple ways a function can be called, potentially with different return types.
It's typical for an interface or type alias describing a function to place all overload signatures next to each other.
If Signatures placed elsewhere in the type are easier to be missed by future developers reading the code.

## Examples

<!--tabs-->

### ❌ Incorrect
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> 84b8e337c (figuring out lint)

```ts
declare namespace Foo {
  export function foo(s: string): void;
  export function foo(n: number): void;
  export function bar(): void;
  export function foo(sn: string | number): void;
}

type Foo = {
  foo(s: string): void;
  foo(n: number): void;
  bar(): void;
  foo(sn: string | number): void;
};

interface Foo {
  foo(s: string): void;
  foo(n: number): void;
  bar(): void;
  foo(sn: string | number): void;
}

class Foo {
  foo(s: string): void;
  foo(n: number): void;
  bar(): void {}
  foo(sn: string | number): void {}
}

export function foo(s: string): void;
export function foo(n: number): void;
export function bar(): void;
export function foo(sn: string | number): void;
```

<<<<<<< HEAD
<<<<<<< HEAD
### ✅ Correct
=======
The following patterns are not warnings:
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
The following patterns are not warnings:
=======
### ✅ Correct
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> 84b8e337c (figuring out lint)

```ts
declare namespace Foo {
  export function foo(s: string): void;
  export function foo(n: number): void;
  export function foo(sn: string | number): void;
  export function bar(): void;
}

type Foo = {
  foo(s: string): void;
  foo(n: number): void;
  foo(sn: string | number): void;
  bar(): void;
};

interface Foo {
  foo(s: string): void;
  foo(n: number): void;
  foo(sn: string | number): void;
  bar(): void;
}

class Foo {
  foo(s: string): void;
  foo(n: number): void;
  foo(sn: string | number): void {}
  bar(): void {}
}

export function bar(): void;
export function foo(s: string): void;
export function foo(n: number): void;
export function foo(sn: string | number): void;
```

## When Not To Use It

If you don't care about the general structure of the code, then you will not need this rule.
<<<<<<< HEAD
<<<<<<< HEAD
=======
=======
>>>>>>> 84b8e337c (figuring out lint)

## Compatibility

- TSLint: [adjacent-overload-signatures](https://palantir.github.io/tslint/rules/adjacent-overload-signatures/)
<<<<<<< HEAD
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> 84b8e337c (figuring out lint)
