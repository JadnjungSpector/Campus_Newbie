/**
 * @fileoverview Disallow undeclared variables in JSX
 * @author Yannick Croissant
 */

'use strict';

const docsUrl = require('../util/docsUrl');
<<<<<<< HEAD
const eslintUtil = require('../util/eslint');
const jsxUtil = require('../util/jsx');
const report = require('../util/report');
=======
const jsxUtil = require('../util/jsx');
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

<<<<<<< HEAD
const messages = {
  undefined: '\'{{identifier}}\' is not defined.',
};

/** @type {import('eslint').Rule.RuleModule} */
=======
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
module.exports = {
  meta: {
    docs: {
      description: 'Disallow undeclared variables in JSX',
      category: 'Possible Errors',
      recommended: true,
<<<<<<< HEAD
      url: docsUrl('jsx-no-undef'),
    },

    messages,

=======
      url: docsUrl('jsx-no-undef')
    },
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
    schema: [{
      type: 'object',
      properties: {
        allowGlobals: {
<<<<<<< HEAD
          type: 'boolean',
        },
      },
      additionalProperties: false,
    }],
=======
          type: 'boolean'
        }
      },
      additionalProperties: false
    }]
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
  },

  create(context) {
    const config = context.options[0] || {};
    const allowGlobals = config.allowGlobals || false;

    /**
     * Compare an identifier with the variables declared in the scope
     * @param {ASTNode} node - Identifier or JSXIdentifier node
     * @returns {void}
     */
    function checkIdentifierInJSX(node) {
<<<<<<< HEAD
      let scope = eslintUtil.getScope(context, node);
      const sourceCode = eslintUtil.getSourceCode(context);
      const sourceType = sourceCode.ast.sourceType;
      const scopeUpperBound = !allowGlobals && sourceType === 'module' ? 'module' : 'global';
      let variables = scope.variables;
=======
      let scope = context.getScope();
      const sourceCode = context.getSourceCode();
      const sourceType = sourceCode.ast.sourceType;
      let variables = scope.variables;
      let scopeType = 'global';
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
      let i;
      let len;

      // Ignore 'this' keyword (also maked as JSXIdentifier when used in JSX)
      if (node.name === 'this') {
        return;
      }

<<<<<<< HEAD
      while (scope.type !== scopeUpperBound && scope.type !== 'global') {
=======
      if (!allowGlobals && sourceType === 'module') {
        scopeType = 'module';
      }

      while (scope.type !== scopeType) {
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
        scope = scope.upper;
        variables = scope.variables.concat(variables);
      }
      if (scope.childScopes.length) {
        variables = scope.childScopes[0].variables.concat(variables);
        // Temporary fix for babel-eslint
        if (scope.childScopes[0].childScopes.length) {
          variables = scope.childScopes[0].childScopes[0].variables.concat(variables);
        }
      }

      for (i = 0, len = variables.length; i < len; i++) {
        if (variables[i].name === node.name) {
          return;
        }
      }

<<<<<<< HEAD
      report(context, messages.undefined, 'undefined', {
        node,
        data: {
          identifier: node.name,
        },
=======
      context.report({
        node,
        message: `'${node.name}' is not defined.`
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
      });
    }

    return {
      JSXOpeningElement(node) {
        switch (node.name.type) {
          case 'JSXIdentifier':
            if (jsxUtil.isDOMComponent(node)) {
              return;
            }
            node = node.name;
            break;
          case 'JSXMemberExpression':
            node = node.name;
            do {
              node = node.object;
            } while (node && node.type !== 'JSXIdentifier');
            break;
          case 'JSXNamespacedName':
<<<<<<< HEAD
            return;
=======
            node = node.name.namespace;
            break;
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
          default:
            break;
        }
        checkIdentifierInJSX(node);
<<<<<<< HEAD
      },
    };
  },
=======
      }
    };
  }
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
};
