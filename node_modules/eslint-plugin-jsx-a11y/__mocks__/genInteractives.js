/**
 * @flow
 */

import { dom, roles } from 'aria-query';
import includes from 'array-includes';
<<<<<<< HEAD
import fromEntries from 'object.fromentries';

import JSXAttributeMock from './JSXAttributeMock';
import JSXElementMock from './JSXElementMock';

import type { JSXAttributeMockType } from './JSXAttributeMock';
import type { JSXElementMockType } from './JSXElementMock';

const domElements = dom.keys();
const roleNames = roles.keys();
=======
import JSXAttributeMock from './JSXAttributeMock';
import JSXElementMock from './JSXElementMock';

import type { TJSXElementMock } from './JSXElementMock';

const domElements = [...dom.keys()];
const roleNames = [...roles.keys()];
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384

const interactiveElementsMap = {
  a: [{ prop: 'href', value: '#' }],
  area: [{ prop: 'href', value: '#' }],
  audio: [],
  button: [],
  canvas: [],
<<<<<<< HEAD
  datalist: [],
  embed: [],
=======
  embed: [],
  label: [],
  link: [],
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
  input: [],
  'input[type="button"]': [{ prop: 'type', value: 'button' }],
  'input[type="checkbox"]': [{ prop: 'type', value: 'checkbox' }],
  'input[type="color"]': [{ prop: 'type', value: 'color' }],
  'input[type="date"]': [{ prop: 'type', value: 'date' }],
  'input[type="datetime"]': [{ prop: 'type', value: 'datetime' }],
  'input[type="email"]': [{ prop: 'type', value: 'email' }],
  'input[type="file"]': [{ prop: 'type', value: 'file' }],
  'input[type="image"]': [{ prop: 'type', value: 'image' }],
  'input[type="month"]': [{ prop: 'type', value: 'month' }],
  'input[type="number"]': [{ prop: 'type', value: 'number' }],
  'input[type="password"]': [{ prop: 'type', value: 'password' }],
  'input[type="radio"]': [{ prop: 'type', value: 'radio' }],
  'input[type="range"]': [{ prop: 'type', value: 'range' }],
  'input[type="reset"]': [{ prop: 'type', value: 'reset' }],
  'input[type="search"]': [{ prop: 'type', value: 'search' }],
  'input[type="submit"]': [{ prop: 'type', value: 'submit' }],
  'input[type="tel"]': [{ prop: 'type', value: 'tel' }],
  'input[type="text"]': [{ prop: 'type', value: 'text' }],
  'input[type="time"]': [{ prop: 'type', value: 'time' }],
  'input[type="url"]': [{ prop: 'type', value: 'url' }],
  'input[type="week"]': [{ prop: 'type', value: 'week' }],
  menuitem: [],
  option: [],
  select: [],
<<<<<<< HEAD
  summary: [],
  // Whereas ARIA makes a distinction between cell and gridcell, the AXObject
  // treats them both as CellRole and since gridcell is interactive, we consider
  // cell interactive as well.
  td: [],
=======
  // Whereas ARIA makes a distinction between cell and gridcell, the AXObject
  // treats them both as CellRole and since gridcell is interactive, we consider
  // cell interactive as well.
  // td: [],
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
  th: [],
  tr: [],
  textarea: [],
  video: [],
};

<<<<<<< HEAD
const nonInteractiveElementsMap: {[string]: Array<{[string]: string}>} = {
  abbr: [],
  address: [],
  article: [],
  aside: [],
  blockquote: [],
  br: [],
  caption: [],
  code: [],
  dd: [],
  del: [],
=======
const nonInteractiveElementsMap = {
  abbr: [],
  article: [],
  blockquote: [],
  br: [],
  caption: [],
  dd: [],
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
  details: [],
  dfn: [],
  dialog: [],
  dir: [],
  dl: [],
  dt: [],
<<<<<<< HEAD
  em: [],
=======
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
  fieldset: [],
  figcaption: [],
  figure: [],
  footer: [],
  form: [],
<<<<<<< HEAD
=======
  frame: [],
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
  h1: [],
  h2: [],
  h3: [],
  h4: [],
  h5: [],
  h6: [],
  hr: [],
<<<<<<< HEAD
  html: [],
  iframe: [],
  img: [],
  ins: [],
  label: [],
=======
  iframe: [],
  img: [],
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
  legend: [],
  li: [],
  main: [],
  mark: [],
  marquee: [],
  menu: [],
  meter: [],
  nav: [],
  ol: [],
<<<<<<< HEAD
  optgroup: [],
  output: [],
=======
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
  p: [],
  pre: [],
  progress: [],
  ruby: [],
<<<<<<< HEAD
  'section[aria-label]': [{ prop: 'aria-label' }],
  'section[aria-labelledby]': [{ prop: 'aria-labelledby' }],
  strong: [],
  sub: [],
  sup: [],
  table: [],
  tbody: [],
=======
  section: [],
  table: [],
  tbody: [],
  td: [],
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
  tfoot: [],
  thead: [],
  time: [],
  ul: [],
};

<<<<<<< HEAD
const indeterminantInteractiveElementsMap: { [key: string]: Array<any> } = fromEntries(domElements.map((name) => [name, []]));

Object.keys(interactiveElementsMap)
  .concat(Object.keys(nonInteractiveElementsMap))
  .forEach((name) => delete indeterminantInteractiveElementsMap[name]);

const abstractRoles = roleNames.filter((role) => roles.get(role).abstract);

const nonAbstractRoles = roleNames.filter((role) => !roles.get(role).abstract);
=======
const indeterminantInteractiveElementsMap = domElements.reduce(
  (accumulator: { [key: string]: Array<any> }, name: string): { [key: string]: Array<any> } => ({
    ...accumulator,
    [name]: [],
  }),
  {},
);

Object.keys(interactiveElementsMap)
  .concat(Object.keys(nonInteractiveElementsMap))
  .forEach((name: string) => delete indeterminantInteractiveElementsMap[name]);

const abstractRoles = roleNames.filter(role => roles.get(role).abstract);

const nonAbstractRoles = roleNames.filter(role => !roles.get(role).abstract);
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384

const interactiveRoles = []
  .concat(
    roleNames,
    // 'toolbar' does not descend from widget, but it does support
    // aria-activedescendant, thus in practice we treat it as a widget.
    'toolbar',
  )
<<<<<<< HEAD
  .filter((role) => (
    !roles.get(role).abstract
    && roles.get(role).superClass.some((klasses) => includes(klasses, 'widget'))
  ));

const nonInteractiveRoles = roleNames
  .filter((role) => (
    !roles.get(role).abstract
    && !roles.get(role).superClass.some((klasses) => includes(klasses, 'widget'))

    // 'toolbar' does not descend from widget, but it does support
    // aria-activedescendant, thus in practice we treat it as a widget.
    && !includes(['toolbar'], role)
  ));

export function genElementSymbol(openingElement: Object): string {
  return (
    openingElement.name.name + (openingElement.attributes.length > 0
      ? `${openingElement.attributes.map((attr) => `[${attr.name.name}="${attr.value.value}"]`).join('')}`
=======
  .filter(role => !roles.get(role).abstract)
  .filter(role => roles.get(role).superClass.some(klasses => includes(klasses, 'widget')));

const nonInteractiveRoles = roleNames
  .filter(role => !roles.get(role).abstract)
  .filter(role => !roles.get(role).superClass.some(klasses => includes(klasses, 'widget')))
  // 'toolbar' does not descend from widget, but it does support
  // aria-activedescendant, thus in practice we treat it as a widget.
  .filter(role => !includes(['toolbar'], role));

export function genElementSymbol(openingElement: Object) {
  return (
    openingElement.name.name + (openingElement.attributes.length > 0
      ? `${openingElement.attributes
        .map(attr => `[${attr.name.name}="${attr.value.value}"]`)
        .join('')}`
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
      : ''
    )
  );
}

<<<<<<< HEAD
export function genInteractiveElements(): Array<JSXElementMockType> {
  return Object.keys(interactiveElementsMap).map((elementSymbol: string): JSXElementMockType => {
=======
export function genInteractiveElements(): Array<TJSXElementMock> {
  return Object.keys(interactiveElementsMap).map((elementSymbol: string): TJSXElementMock => {
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
    const bracketIndex = elementSymbol.indexOf('[');
    let name = elementSymbol;
    if (bracketIndex > -1) {
      name = elementSymbol.slice(0, bracketIndex);
    }
    const attributes = interactiveElementsMap[elementSymbol].map(({ prop, value }) => JSXAttributeMock(prop, value));
    return JSXElementMock(name, attributes);
  });
}

<<<<<<< HEAD
export function genInteractiveRoleElements(): Array<JSXElementMockType> {
  return interactiveRoles.concat('button article', 'fakerole button article').map((value): JSXElementMockType => JSXElementMock(
=======
export function genInteractiveRoleElements(): Array<TJSXElementMock> {
  return [...interactiveRoles, 'button article', 'fakerole button article'].map((value): TJSXElementMock => JSXElementMock(
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
    'div',
    [JSXAttributeMock('role', value)],
  ));
}

<<<<<<< HEAD
export function genNonInteractiveElements(): Array<JSXElementMockType> {
  return Object.keys(nonInteractiveElementsMap).map((elementSymbol): JSXElementMockType => {
=======
export function genNonInteractiveElements(): Array<TJSXElementMock> {
  return Object.keys(nonInteractiveElementsMap).map((elementSymbol): TJSXElementMock => {
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
    const bracketIndex = elementSymbol.indexOf('[');
    let name = elementSymbol;
    if (bracketIndex > -1) {
      name = elementSymbol.slice(0, bracketIndex);
    }
    const attributes = nonInteractiveElementsMap[elementSymbol].map(({ prop, value }) => JSXAttributeMock(prop, value));
    return JSXElementMock(name, attributes);
  });
}

<<<<<<< HEAD
export function genNonInteractiveRoleElements(): Array<JSXElementMockType> {
=======
export function genNonInteractiveRoleElements() {
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
  return [
    ...nonInteractiveRoles,
    'article button',
    'fakerole article button',
<<<<<<< HEAD
  ].map((value) => JSXElementMock('div', [JSXAttributeMock('role', value)]));
}

export function genAbstractRoleElements(): Array<JSXElementMockType> {
  return abstractRoles.map((value) => JSXElementMock('div', [JSXAttributeMock('role', value)]));
}

export function genNonAbstractRoleElements(): Array<JSXElementMockType> {
  return nonAbstractRoles.map((value) => JSXElementMock('div', [JSXAttributeMock('role', value)]));
}

export function genIndeterminantInteractiveElements(): Array<JSXElementMockType> {
  return Object.keys(indeterminantInteractiveElementsMap).map((name) => {
    const attributes = indeterminantInteractiveElementsMap[name].map(({ prop, value }): JSXAttributeMockType => JSXAttributeMock(prop, value));
=======
  ].map(value => JSXElementMock('div', [JSXAttributeMock('role', value)]));
}

export function genAbstractRoleElements() {
  return abstractRoles.map(value => JSXElementMock('div', [JSXAttributeMock('role', value)]));
}

export function genNonAbstractRoleElements() {
  return nonAbstractRoles.map(value => JSXElementMock('div', [JSXAttributeMock('role', value)]));
}

export function genIndeterminantInteractiveElements(): Array<TJSXElementMock> {
  return Object.keys(indeterminantInteractiveElementsMap).map((name) => {
    const attributes = indeterminantInteractiveElementsMap[name].map(({ prop, value }): TJSXElementMock => JSXAttributeMock(prop, value));
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
    return JSXElementMock(name, attributes);
  });
}
