/**
 * @fileoverview A rule to suggest using arrow functions as callbacks.
 * @author Toru Nagashima
 */

"use strict";

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
const astUtils = require("./utils/ast-utils");

=======
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
=======
>>>>>>> bda8256cb (figuring out lint)
=======
=======
>>>>>>> 5209f27ef (figuring out lint)
const astUtils = require("./utils/ast-utils");

>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> ee12506f5 (figuring out lint)
=======
<<<<<<< HEAD
const astUtils = require("./utils/ast-utils");

>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> 84b8e337c (figuring out lint)
=======
=======
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
const astUtils = require("./utils/ast-utils");

>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> 84b8e337c (figuring out lint)
>>>>>>> 5209f27ef (figuring out lint)
>>>>>>> bda8256cb (figuring out lint)
//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks whether or not a given variable is a function name.
 * @param {eslint-scope.Variable} variable A variable to check.
 * @returns {boolean} `true` if the variable is a function name.
 */
function isFunctionName(variable) {
    return variable && variable.defs[0].type === "FunctionName";
}

/**
 * Checks whether or not a given MetaProperty node equals to a given value.
 * @param {ASTNode} node A MetaProperty node to check.
 * @param {string} metaName The name of `MetaProperty.meta`.
 * @param {string} propertyName The name of `MetaProperty.property`.
 * @returns {boolean} `true` if the node is the specific value.
 */
function checkMetaProperty(node, metaName, propertyName) {
    return node.meta.name === metaName && node.property.name === propertyName;
}

/**
 * Gets the variable object of `arguments` which is defined implicitly.
 * @param {eslint-scope.Scope} scope A scope to get.
 * @returns {eslint-scope.Variable} The found variable object.
 */
function getVariableOfArguments(scope) {
    const variables = scope.variables;

    for (let i = 0; i < variables.length; ++i) {
        const variable = variables[i];

        if (variable.name === "arguments") {

            /*
             * If there was a parameter which is named "arguments", the
             * implicit "arguments" is not defined.
             * So does fast return with null.
             */
            return (variable.identifiers.length === 0) ? variable : null;
        }
    }

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
    /* c8 ignore next */
=======
    /* istanbul ignore next */
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
>>>>>>> ee12506f5 (figuring out lint)
=======
>>>>>>> bda8256cb (figuring out lint)
    /* istanbul ignore next */
=======
    /* c8 ignore next */
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> 84b8e337c (figuring out lint)
=======
=======
    /* c8 ignore next */
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> ee12506f5 (figuring out lint)
=======
=======
    /* c8 ignore next */
=======
    /* istanbul ignore next */
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
    /* istanbul ignore next */
=======
    /* c8 ignore next */
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> 84b8e337c (figuring out lint)
>>>>>>> 5209f27ef (figuring out lint)
>>>>>>> bda8256cb (figuring out lint)
    return null;
}

/**
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
 * Checks whether or not a given node is a callback.
 * @param {ASTNode} node A node to check.
 * @throws {Error} (Unreachable.)
=======
 * Checkes whether or not a given node is a callback.
 * @param {ASTNode} node A node to check.
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
>>>>>>> ee12506f5 (figuring out lint)
=======
 * Checkes whether or not a given node is a callback.
 * @param {ASTNode} node A node to check.
=======
=======
>>>>>>> 5209f27ef (figuring out lint)
 * Checks whether or not a given node is a callback.
 * @param {ASTNode} node A node to check.
 * @throws {Error} (Unreachable.)
>>>>>>> 6be43a322 (figuring out lint)
=======
 * Checks whether or not a given node is a callback.
 * @param {ASTNode} node A node to check.
<<<<<<< HEAD
 * @throws {Error} (Unreachable.)
>>>>>>> 6be43a322 (figuring out lint)
=======
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
>>>>>>> bda8256cb (figuring out lint)
 * Checkes whether or not a given node is a callback.
 * @param {ASTNode} node A node to check.
=======
 * Checks whether or not a given node is a callback.
 * @param {ASTNode} node A node to check.
 * @throws {Error} (Unreachable.)
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
<<<<<<< HEAD
>>>>>>> 84b8e337c (figuring out lint)
=======
=======
 * Checks whether or not a given node is a callback.
 * @param {ASTNode} node A node to check.
 * @throws {Error} (Unreachable.)
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> ee12506f5 (figuring out lint)
=======
>>>>>>> 84b8e337c (figuring out lint)
>>>>>>> 5209f27ef (figuring out lint)
>>>>>>> bda8256cb (figuring out lint)
 * @returns {Object}
 *   {boolean} retv.isCallback - `true` if the node is a callback.
 *   {boolean} retv.isLexicalThis - `true` if the node is with `.bind(this)`.
 */
function getCallbackInfo(node) {
    const retv = { isCallback: false, isLexicalThis: false };
    let currentNode = node;
    let parent = node.parent;
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
    let bound = false;
=======
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
=======
>>>>>>> bda8256cb (figuring out lint)
=======
    let bound = false;
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> ee12506f5 (figuring out lint)
=======
    let bound = false;
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> 84b8e337c (figuring out lint)
=======
=======
    let bound = false;
=======
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
    let bound = false;
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> 84b8e337c (figuring out lint)
>>>>>>> 5209f27ef (figuring out lint)
>>>>>>> bda8256cb (figuring out lint)

    while (currentNode) {
        switch (parent.type) {

            // Checks parents recursively.

            case "LogicalExpression":
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
            case "ChainExpression":
=======
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
=======
>>>>>>> bda8256cb (figuring out lint)
=======
            case "ChainExpression":
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> ee12506f5 (figuring out lint)
=======
            case "ChainExpression":
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> 84b8e337c (figuring out lint)
=======
=======
            case "ChainExpression":
=======
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
            case "ChainExpression":
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> 84b8e337c (figuring out lint)
>>>>>>> 5209f27ef (figuring out lint)
>>>>>>> bda8256cb (figuring out lint)
            case "ConditionalExpression":
                break;

            // Checks whether the parent node is `.bind(this)` call.
            case "MemberExpression":
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
                if (
                    parent.object === currentNode &&
                    !parent.property.computed &&
                    parent.property.type === "Identifier" &&
                    parent.property.name === "bind"
                ) {
                    const maybeCallee = parent.parent.type === "ChainExpression"
                        ? parent.parent
                        : parent;

                    if (astUtils.isCallee(maybeCallee)) {
                        if (!bound) {
                            bound = true; // Use only the first `.bind()` to make `isLexicalThis` value.
                            retv.isLexicalThis = (
                                maybeCallee.parent.arguments.length === 1 &&
                                maybeCallee.parent.arguments[0].type === "ThisExpression"
                            );
                        }
                        parent = maybeCallee.parent;
                    } else {
                        return retv;
                    }
=======
=======
>>>>>>> 84b8e337c (figuring out lint)
=======
>>>>>>> ee12506f5 (figuring out lint)
=======
>>>>>>> bda8256cb (figuring out lint)
                if (parent.object === currentNode &&
                    !parent.property.computed &&
                    parent.property.type === "Identifier" &&
                    parent.property.name === "bind" &&
                    parent.parent.type === "CallExpression" &&
                    parent.parent.callee === parent
                ) {
                    retv.isLexicalThis = (
                        parent.parent.arguments.length === 1 &&
                        parent.parent.arguments[0].type === "ThisExpression"
                    );
                    parent = parent.parent;
<<<<<<< HEAD
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
=======
>>>>>>> 6be43a322 (figuring out lint)
=======
>>>>>>> 5209f27ef (figuring out lint)
                if (
                    parent.object === currentNode &&
                    !parent.property.computed &&
                    parent.property.type === "Identifier" &&
                    parent.property.name === "bind"
                ) {
                    const maybeCallee = parent.parent.type === "ChainExpression"
                        ? parent.parent
                        : parent;

                    if (astUtils.isCallee(maybeCallee)) {
                        if (!bound) {
                            bound = true; // Use only the first `.bind()` to make `isLexicalThis` value.
                            retv.isLexicalThis = (
                                maybeCallee.parent.arguments.length === 1 &&
                                maybeCallee.parent.arguments[0].type === "ThisExpression"
                            );
                        }
                        parent = maybeCallee.parent;
                    } else {
                        return retv;
                    }
<<<<<<< HEAD
>>>>>>> 6be43a322 (figuring out lint)
=======
<<<<<<< HEAD
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> 84b8e337c (figuring out lint)
=======
=======
=======
>>>>>>> 84b8e337c (figuring out lint)
                if (parent.object === currentNode &&
                    !parent.property.computed &&
                    parent.property.type === "Identifier" &&
                    parent.property.name === "bind" &&
                    parent.parent.type === "CallExpression" &&
                    parent.parent.callee === parent
                ) {
                    retv.isLexicalThis = (
                        parent.parent.arguments.length === 1 &&
                        parent.parent.arguments[0].type === "ThisExpression"
                    );
                    parent = parent.parent;
<<<<<<< HEAD
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
                if (
                    parent.object === currentNode &&
                    !parent.property.computed &&
                    parent.property.type === "Identifier" &&
                    parent.property.name === "bind"
                ) {
                    const maybeCallee = parent.parent.type === "ChainExpression"
                        ? parent.parent
                        : parent;

                    if (astUtils.isCallee(maybeCallee)) {
                        if (!bound) {
                            bound = true; // Use only the first `.bind()` to make `isLexicalThis` value.
                            retv.isLexicalThis = (
                                maybeCallee.parent.arguments.length === 1 &&
                                maybeCallee.parent.arguments[0].type === "ThisExpression"
                            );
                        }
                        parent = maybeCallee.parent;
                    } else {
                        return retv;
                    }
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> 84b8e337c (figuring out lint)
>>>>>>> 5209f27ef (figuring out lint)
>>>>>>> bda8256cb (figuring out lint)
                } else {
                    return retv;
                }
                break;

            // Checks whether the node is a callback.
            case "CallExpression":
            case "NewExpression":
                if (parent.callee !== currentNode) {
                    retv.isCallback = true;
                }
                return retv;

            default:
                return retv;
        }

        currentNode = parent;
        parent = parent.parent;
    }

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
    /* c8 ignore next */
=======
    /* istanbul ignore next */
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
>>>>>>> ee12506f5 (figuring out lint)
=======
>>>>>>> bda8256cb (figuring out lint)
    /* istanbul ignore next */
=======
    /* c8 ignore next */
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> 84b8e337c (figuring out lint)
=======
=======
    /* c8 ignore next */
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> ee12506f5 (figuring out lint)
=======
=======
    /* c8 ignore next */
=======
    /* istanbul ignore next */
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
    /* istanbul ignore next */
=======
    /* c8 ignore next */
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> 84b8e337c (figuring out lint)
>>>>>>> 5209f27ef (figuring out lint)
>>>>>>> bda8256cb (figuring out lint)
    throw new Error("unreachable");
}

/**
 * Checks whether a simple list of parameters contains any duplicates. This does not handle complex
 * parameter lists (e.g. with destructuring), since complex parameter lists are a SyntaxError with duplicate
 * parameter names anyway. Instead, it always returns `false` for complex parameter lists.
 * @param {ASTNode[]} paramsList The list of parameters for a function
 * @returns {boolean} `true` if the list of parameters contains any duplicates
 */
function hasDuplicateParams(paramsList) {
    return paramsList.every(param => param.type === "Identifier") && paramsList.length !== new Set(paramsList.map(param => param.name)).size;
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
/** @type {import('../shared/types').Rule} */
=======
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
=======
>>>>>>> bda8256cb (figuring out lint)
=======
/** @type {import('../shared/types').Rule} */
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> ee12506f5 (figuring out lint)
=======
/** @type {import('../shared/types').Rule} */
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> 84b8e337c (figuring out lint)
=======
=======
/** @type {import('../shared/types').Rule} */
=======
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
/** @type {import('../shared/types').Rule} */
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> 84b8e337c (figuring out lint)
>>>>>>> 5209f27ef (figuring out lint)
>>>>>>> bda8256cb (figuring out lint)
module.exports = {
    meta: {
        type: "suggestion",

        docs: {
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
=======
=======
>>>>>>> bda8256cb (figuring out lint)
            description: "Require using arrow functions for callbacks",
            recommended: false,
            url: "https://eslint.org/docs/latest/rules/prefer-arrow-callback"
=======
=======
>>>>>>> 84b8e337c (figuring out lint)
<<<<<<< HEAD
=======
>>>>>>> ee12506f5 (figuring out lint)
=======
>>>>>>> 5209f27ef (figuring out lint)
>>>>>>> bda8256cb (figuring out lint)
            description: "require using arrow functions for callbacks",
            category: "ECMAScript 6",
            recommended: false,
            url: "https://eslint.org/docs/rules/prefer-arrow-callback"
<<<<<<< HEAD
<<<<<<< HEAD
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
=======
<<<<<<< HEAD
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
>>>>>>> 5209f27ef (figuring out lint)
=======
            description: "Require using arrow functions for callbacks",
            recommended: false,
            url: "https://eslint.org/docs/latest/rules/prefer-arrow-callback"
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> bda8256cb (figuring out lint)
=======
            description: "Require using arrow functions for callbacks",
            recommended: false,
            url: "https://eslint.org/docs/latest/rules/prefer-arrow-callback"
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> 84b8e337c (figuring out lint)
=======
=======
<<<<<<< HEAD
            description: "Require using arrow functions for callbacks",
            recommended: false,
            url: "https://eslint.org/docs/latest/rules/prefer-arrow-callback"
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> ee12506f5 (figuring out lint)
=======
>>>>>>> 84b8e337c (figuring out lint)
>>>>>>> 5209f27ef (figuring out lint)
>>>>>>> bda8256cb (figuring out lint)
        },

        schema: [
            {
                type: "object",
                properties: {
                    allowNamedFunctions: {
                        type: "boolean",
                        default: false
                    },
                    allowUnboundThis: {
                        type: "boolean",
                        default: true
                    }
                },
                additionalProperties: false
            }
        ],

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
        fixable: "code",

        messages: {
            preferArrowCallback: "Unexpected function expression."
        }
=======
        fixable: "code"
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
>>>>>>> ee12506f5 (figuring out lint)
=======
>>>>>>> bda8256cb (figuring out lint)
        fixable: "code"
=======
=======
>>>>>>> 6be43a322 (figuring out lint)
=======
>>>>>>> 5209f27ef (figuring out lint)
        fixable: "code",

        messages: {
            preferArrowCallback: "Unexpected function expression."
        }
<<<<<<< HEAD
>>>>>>> 6be43a322 (figuring out lint)
=======
<<<<<<< HEAD
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> 84b8e337c (figuring out lint)
=======
=======
        fixable: "code"
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
        fixable: "code"
=======
        fixable: "code",

        messages: {
            preferArrowCallback: "Unexpected function expression."
        }
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> 84b8e337c (figuring out lint)
>>>>>>> 5209f27ef (figuring out lint)
>>>>>>> bda8256cb (figuring out lint)
    },

    create(context) {
        const options = context.options[0] || {};

        const allowUnboundThis = options.allowUnboundThis !== false; // default to true
        const allowNamedFunctions = options.allowNamedFunctions;
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
        const sourceCode = context.sourceCode;
=======
        const sourceCode = context.getSourceCode();
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
>>>>>>> ee12506f5 (figuring out lint)
=======
>>>>>>> bda8256cb (figuring out lint)
        const sourceCode = context.getSourceCode();
=======
        const sourceCode = context.sourceCode;
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> 84b8e337c (figuring out lint)
=======
=======
        const sourceCode = context.sourceCode;
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> ee12506f5 (figuring out lint)
=======
=======
        const sourceCode = context.sourceCode;
=======
        const sourceCode = context.getSourceCode();
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
        const sourceCode = context.getSourceCode();
=======
        const sourceCode = context.sourceCode;
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> 84b8e337c (figuring out lint)
>>>>>>> 5209f27ef (figuring out lint)
>>>>>>> bda8256cb (figuring out lint)

        /*
         * {Array<{this: boolean, super: boolean, meta: boolean}>}
         * - this - A flag which shows there are one or more ThisExpression.
         * - super - A flag which shows there are one or more Super.
         * - meta - A flag which shows there are one or more MethProperty.
         */
        let stack = [];

        /**
         * Pushes new function scope with all `false` flags.
         * @returns {void}
         */
        function enterScope() {
            stack.push({ this: false, super: false, meta: false });
        }

        /**
         * Pops a function scope from the stack.
         * @returns {{this: boolean, super: boolean, meta: boolean}} The information of the last scope.
         */
        function exitScope() {
            return stack.pop();
        }

        return {

            // Reset internal state.
            Program() {
                stack = [];
            },

            // If there are below, it cannot replace with arrow functions merely.
            ThisExpression() {
                const info = stack[stack.length - 1];

                if (info) {
                    info.this = true;
                }
            },

            Super() {
                const info = stack[stack.length - 1];

                if (info) {
                    info.super = true;
                }
            },

            MetaProperty(node) {
                const info = stack[stack.length - 1];

                if (info && checkMetaProperty(node, "new", "target")) {
                    info.meta = true;
                }
            },

            // To skip nested scopes.
            FunctionDeclaration: enterScope,
            "FunctionDeclaration:exit": exitScope,

            // Main.
            FunctionExpression: enterScope,
            "FunctionExpression:exit"(node) {
                const scopeInfo = exitScope();

                // Skip named function expressions
                if (allowNamedFunctions && node.id && node.id.name) {
                    return;
                }

                // Skip generators.
                if (node.generator) {
                    return;
                }

                // Skip recursive functions.
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
                const nameVar = sourceCode.getDeclaredVariables(node)[0];
=======
                const nameVar = context.getDeclaredVariables(node)[0];
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
>>>>>>> ee12506f5 (figuring out lint)
=======
>>>>>>> bda8256cb (figuring out lint)
                const nameVar = context.getDeclaredVariables(node)[0];
=======
                const nameVar = sourceCode.getDeclaredVariables(node)[0];
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> 84b8e337c (figuring out lint)
=======
=======
                const nameVar = sourceCode.getDeclaredVariables(node)[0];
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> ee12506f5 (figuring out lint)
=======
=======
                const nameVar = sourceCode.getDeclaredVariables(node)[0];
=======
                const nameVar = context.getDeclaredVariables(node)[0];
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
                const nameVar = context.getDeclaredVariables(node)[0];
=======
                const nameVar = sourceCode.getDeclaredVariables(node)[0];
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> 84b8e337c (figuring out lint)
>>>>>>> 5209f27ef (figuring out lint)
>>>>>>> bda8256cb (figuring out lint)

                if (isFunctionName(nameVar) && nameVar.references.length > 0) {
                    return;
                }

                // Skip if it's using arguments.
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
                const variable = getVariableOfArguments(sourceCode.getScope(node));
=======
                const variable = getVariableOfArguments(context.getScope());
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
>>>>>>> ee12506f5 (figuring out lint)
=======
>>>>>>> bda8256cb (figuring out lint)
                const variable = getVariableOfArguments(context.getScope());
=======
                const variable = getVariableOfArguments(sourceCode.getScope(node));
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> 84b8e337c (figuring out lint)
=======
=======
                const variable = getVariableOfArguments(sourceCode.getScope(node));
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> ee12506f5 (figuring out lint)
=======
=======
                const variable = getVariableOfArguments(sourceCode.getScope(node));
=======
                const variable = getVariableOfArguments(context.getScope());
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
                const variable = getVariableOfArguments(context.getScope());
=======
                const variable = getVariableOfArguments(sourceCode.getScope(node));
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> 84b8e337c (figuring out lint)
>>>>>>> 5209f27ef (figuring out lint)
>>>>>>> bda8256cb (figuring out lint)

                if (variable && variable.references.length > 0) {
                    return;
                }

                // Reports if it's a callback which can replace with arrows.
                const callbackInfo = getCallbackInfo(node);

                if (callbackInfo.isCallback &&
                    (!allowUnboundThis || !scopeInfo.this || callbackInfo.isLexicalThis) &&
                    !scopeInfo.super &&
                    !scopeInfo.meta
                ) {
                    context.report({
                        node,
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
                        messageId: "preferArrowCallback",
                        *fix(fixer) {
=======
                        message: "Unexpected function expression.",
                        fix(fixer) {
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
>>>>>>> ee12506f5 (figuring out lint)
=======
>>>>>>> bda8256cb (figuring out lint)
                        message: "Unexpected function expression.",
                        fix(fixer) {
=======
                        messageId: "preferArrowCallback",
                        *fix(fixer) {
<<<<<<< HEAD
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> 84b8e337c (figuring out lint)
=======
=======
=======
                        message: "Unexpected function expression.",
                        fix(fixer) {
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
                        message: "Unexpected function expression.",
                        fix(fixer) {
>>>>>>> 5209f27ef (figuring out lint)
>>>>>>> bda8256cb (figuring out lint)
=======
                        messageId: "preferArrowCallback",
                        *fix(fixer) {
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> ee12506f5 (figuring out lint)
=======
<<<<<<< HEAD
=======
                        messageId: "preferArrowCallback",
                        *fix(fixer) {
>>>>>>> 6be43a322 (figuring out lint)
=======
>>>>>>> 84b8e337c (figuring out lint)
>>>>>>> 5209f27ef (figuring out lint)
>>>>>>> bda8256cb (figuring out lint)
                            if ((!callbackInfo.isLexicalThis && scopeInfo.this) || hasDuplicateParams(node.params)) {

                                /*
                                 * If the callback function does not have .bind(this) and contains a reference to `this`, there
                                 * is no way to determine what `this` should be, so don't perform any fixes.
                                 * If the callback function has duplicates in its list of parameters (possible in sloppy mode),
                                 * don't replace it with an arrow function, because this is a SyntaxError with arrow functions.
                                 */
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
                                return;
                            }

                            // Remove `.bind(this)` if exists.
                            if (callbackInfo.isLexicalThis) {
                                const memberNode = node.parent;

                                /*
                                 * If `.bind(this)` exists but the parent is not `.bind(this)`, don't remove it automatically.
                                 * E.g. `(foo || function(){}).bind(this)`
                                 */
                                if (memberNode.type !== "MemberExpression") {
                                    return;
                                }

                                const callNode = memberNode.parent;
                                const firstTokenToRemove = sourceCode.getTokenAfter(memberNode.object, astUtils.isNotClosingParenToken);
                                const lastTokenToRemove = sourceCode.getLastToken(callNode);

                                /*
                                 * If the member expression is parenthesized, don't remove the right paren.
                                 * E.g. `(function(){}.bind)(this)`
                                 *                    ^^^^^^^^^^^^
                                 */
                                if (astUtils.isParenthesised(sourceCode, memberNode)) {
                                    return;
                                }

                                // If comments exist in the `.bind(this)`, don't remove those.
                                if (sourceCode.commentsExistBetween(firstTokenToRemove, lastTokenToRemove)) {
                                    return;
                                }

                                yield fixer.removeRange([firstTokenToRemove.range[0], lastTokenToRemove.range[1]]);
                            }

                            // Convert the function expression to an arrow function.
                            const functionToken = sourceCode.getFirstToken(node, node.async ? 1 : 0);
                            const leftParenToken = sourceCode.getTokenAfter(functionToken, astUtils.isOpeningParenToken);
                            const tokenBeforeBody = sourceCode.getTokenBefore(node.body);

                            if (sourceCode.commentsExistBetween(functionToken, leftParenToken)) {

                                // Remove only extra tokens to keep comments.
                                yield fixer.remove(functionToken);
                                if (node.id) {
                                    yield fixer.remove(node.id);
                                }
                            } else {

                                // Remove extra tokens and spaces.
                                yield fixer.removeRange([functionToken.range[0], leftParenToken.range[0]]);
                            }
                            yield fixer.insertTextAfter(tokenBeforeBody, " =>");

                            // Get the node that will become the new arrow function.
                            let replacedNode = callbackInfo.isLexicalThis ? node.parent.parent : node;

                            if (replacedNode.type === "ChainExpression") {
                                replacedNode = replacedNode.parent;
                            }
=======
=======
>>>>>>> 84b8e337c (figuring out lint)
=======
>>>>>>> ee12506f5 (figuring out lint)
=======
>>>>>>> bda8256cb (figuring out lint)
                                return null;
                            }

                            const paramsLeftParen = node.params.length ? sourceCode.getTokenBefore(node.params[0]) : sourceCode.getTokenBefore(node.body, 1);
                            const paramsRightParen = sourceCode.getTokenBefore(node.body);
                            const asyncKeyword = node.async ? "async " : "";
                            const paramsFullText = sourceCode.text.slice(paramsLeftParen.range[0], paramsRightParen.range[1]);
                            const arrowFunctionText = `${asyncKeyword}${paramsFullText} => ${sourceCode.getText(node.body)}`;

                            /*
                             * If the callback function has `.bind(this)`, replace it with an arrow function and remove the binding.
                             * Otherwise, just replace the arrow function itself.
                             */
                            const replacedNode = callbackInfo.isLexicalThis ? node.parent.parent : node;
<<<<<<< HEAD
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
=======
>>>>>>> 6be43a322 (figuring out lint)
=======
>>>>>>> 5209f27ef (figuring out lint)
                                return;
                            }

                            // Remove `.bind(this)` if exists.
                            if (callbackInfo.isLexicalThis) {
                                const memberNode = node.parent;

                                /*
                                 * If `.bind(this)` exists but the parent is not `.bind(this)`, don't remove it automatically.
                                 * E.g. `(foo || function(){}).bind(this)`
                                 */
                                if (memberNode.type !== "MemberExpression") {
                                    return;
                                }

                                const callNode = memberNode.parent;
                                const firstTokenToRemove = sourceCode.getTokenAfter(memberNode.object, astUtils.isNotClosingParenToken);
                                const lastTokenToRemove = sourceCode.getLastToken(callNode);

                                /*
                                 * If the member expression is parenthesized, don't remove the right paren.
                                 * E.g. `(function(){}.bind)(this)`
                                 *                    ^^^^^^^^^^^^
                                 */
                                if (astUtils.isParenthesised(sourceCode, memberNode)) {
                                    return;
                                }

                                // If comments exist in the `.bind(this)`, don't remove those.
                                if (sourceCode.commentsExistBetween(firstTokenToRemove, lastTokenToRemove)) {
                                    return;
                                }

                                yield fixer.removeRange([firstTokenToRemove.range[0], lastTokenToRemove.range[1]]);
                            }

                            // Convert the function expression to an arrow function.
                            const functionToken = sourceCode.getFirstToken(node, node.async ? 1 : 0);
                            const leftParenToken = sourceCode.getTokenAfter(functionToken, astUtils.isOpeningParenToken);
                            const tokenBeforeBody = sourceCode.getTokenBefore(node.body);

                            if (sourceCode.commentsExistBetween(functionToken, leftParenToken)) {

                                // Remove only extra tokens to keep comments.
                                yield fixer.remove(functionToken);
                                if (node.id) {
                                    yield fixer.remove(node.id);
                                }
                            } else {

                                // Remove extra tokens and spaces.
                                yield fixer.removeRange([functionToken.range[0], leftParenToken.range[0]]);
                            }
                            yield fixer.insertTextAfter(tokenBeforeBody, " =>");

                            // Get the node that will become the new arrow function.
                            let replacedNode = callbackInfo.isLexicalThis ? node.parent.parent : node;

                            if (replacedNode.type === "ChainExpression") {
                                replacedNode = replacedNode.parent;
                            }
<<<<<<< HEAD
>>>>>>> 6be43a322 (figuring out lint)
=======
<<<<<<< HEAD
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> 84b8e337c (figuring out lint)
=======
=======
=======
>>>>>>> 84b8e337c (figuring out lint)
                                return null;
                            }

                            const paramsLeftParen = node.params.length ? sourceCode.getTokenBefore(node.params[0]) : sourceCode.getTokenBefore(node.body, 1);
                            const paramsRightParen = sourceCode.getTokenBefore(node.body);
                            const asyncKeyword = node.async ? "async " : "";
                            const paramsFullText = sourceCode.text.slice(paramsLeftParen.range[0], paramsRightParen.range[1]);
                            const arrowFunctionText = `${asyncKeyword}${paramsFullText} => ${sourceCode.getText(node.body)}`;

                            /*
                             * If the callback function has `.bind(this)`, replace it with an arrow function and remove the binding.
                             * Otherwise, just replace the arrow function itself.
                             */
                            const replacedNode = callbackInfo.isLexicalThis ? node.parent.parent : node;
<<<<<<< HEAD
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
                                return;
                            }

                            // Remove `.bind(this)` if exists.
                            if (callbackInfo.isLexicalThis) {
                                const memberNode = node.parent;

                                /*
                                 * If `.bind(this)` exists but the parent is not `.bind(this)`, don't remove it automatically.
                                 * E.g. `(foo || function(){}).bind(this)`
                                 */
                                if (memberNode.type !== "MemberExpression") {
                                    return;
                                }

                                const callNode = memberNode.parent;
                                const firstTokenToRemove = sourceCode.getTokenAfter(memberNode.object, astUtils.isNotClosingParenToken);
                                const lastTokenToRemove = sourceCode.getLastToken(callNode);

                                /*
                                 * If the member expression is parenthesized, don't remove the right paren.
                                 * E.g. `(function(){}.bind)(this)`
                                 *                    ^^^^^^^^^^^^
                                 */
                                if (astUtils.isParenthesised(sourceCode, memberNode)) {
                                    return;
                                }

                                // If comments exist in the `.bind(this)`, don't remove those.
                                if (sourceCode.commentsExistBetween(firstTokenToRemove, lastTokenToRemove)) {
                                    return;
                                }

                                yield fixer.removeRange([firstTokenToRemove.range[0], lastTokenToRemove.range[1]]);
                            }

                            // Convert the function expression to an arrow function.
                            const functionToken = sourceCode.getFirstToken(node, node.async ? 1 : 0);
                            const leftParenToken = sourceCode.getTokenAfter(functionToken, astUtils.isOpeningParenToken);
                            const tokenBeforeBody = sourceCode.getTokenBefore(node.body);

                            if (sourceCode.commentsExistBetween(functionToken, leftParenToken)) {

                                // Remove only extra tokens to keep comments.
                                yield fixer.remove(functionToken);
                                if (node.id) {
                                    yield fixer.remove(node.id);
                                }
                            } else {

                                // Remove extra tokens and spaces.
                                yield fixer.removeRange([functionToken.range[0], leftParenToken.range[0]]);
                            }
                            yield fixer.insertTextAfter(tokenBeforeBody, " =>");

                            // Get the node that will become the new arrow function.
                            let replacedNode = callbackInfo.isLexicalThis ? node.parent.parent : node;

                            if (replacedNode.type === "ChainExpression") {
                                replacedNode = replacedNode.parent;
                            }
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> 84b8e337c (figuring out lint)
>>>>>>> 5209f27ef (figuring out lint)
>>>>>>> bda8256cb (figuring out lint)

                            /*
                             * If the replaced node is part of a BinaryExpression, LogicalExpression, or MemberExpression, then
                             * the arrow function needs to be parenthesized, because `foo || () => {}` is invalid syntax even
                             * though `foo || function() {}` is valid.
                             */
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
                            if (
                                replacedNode.parent.type !== "CallExpression" &&
                                replacedNode.parent.type !== "ConditionalExpression" &&
                                !astUtils.isParenthesised(sourceCode, replacedNode) &&
                                !astUtils.isParenthesised(sourceCode, node)
                            ) {
                                yield fixer.insertTextBefore(replacedNode, "(");
                                yield fixer.insertTextAfter(replacedNode, ")");
                            }
=======
=======
>>>>>>> 84b8e337c (figuring out lint)
=======
>>>>>>> ee12506f5 (figuring out lint)
=======
>>>>>>> bda8256cb (figuring out lint)
                            const needsParens = replacedNode.parent.type !== "CallExpression" && replacedNode.parent.type !== "ConditionalExpression";
                            const replacementText = needsParens ? `(${arrowFunctionText})` : arrowFunctionText;

                            return fixer.replaceText(replacedNode, replacementText);
<<<<<<< HEAD
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
=======
>>>>>>> 6be43a322 (figuring out lint)
=======
>>>>>>> 5209f27ef (figuring out lint)
                            if (
                                replacedNode.parent.type !== "CallExpression" &&
                                replacedNode.parent.type !== "ConditionalExpression" &&
                                !astUtils.isParenthesised(sourceCode, replacedNode) &&
                                !astUtils.isParenthesised(sourceCode, node)
                            ) {
                                yield fixer.insertTextBefore(replacedNode, "(");
                                yield fixer.insertTextAfter(replacedNode, ")");
                            }
<<<<<<< HEAD
>>>>>>> 6be43a322 (figuring out lint)
=======
<<<<<<< HEAD
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> 84b8e337c (figuring out lint)
=======
=======
=======
>>>>>>> 84b8e337c (figuring out lint)
                            const needsParens = replacedNode.parent.type !== "CallExpression" && replacedNode.parent.type !== "ConditionalExpression";
                            const replacementText = needsParens ? `(${arrowFunctionText})` : arrowFunctionText;

                            return fixer.replaceText(replacedNode, replacementText);
<<<<<<< HEAD
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
                            if (
                                replacedNode.parent.type !== "CallExpression" &&
                                replacedNode.parent.type !== "ConditionalExpression" &&
                                !astUtils.isParenthesised(sourceCode, replacedNode) &&
                                !astUtils.isParenthesised(sourceCode, node)
                            ) {
                                yield fixer.insertTextBefore(replacedNode, "(");
                                yield fixer.insertTextAfter(replacedNode, ")");
                            }
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> 84b8e337c (figuring out lint)
>>>>>>> 5209f27ef (figuring out lint)
>>>>>>> bda8256cb (figuring out lint)
                        }
                    });
                }
            }
        };
    }
};
