/**
 * @fileoverview Rule to warn when a function expression does not have a name.
 * @author Kyle T. Nunery
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

/**
 * Checks whether or not a given variable is a function name.
 * @param {eslint-scope.Variable} variable A variable to check.
 * @returns {boolean} `true` if the variable is a function name.
 */
function isFunctionName(variable) {
    return variable && variable.defs[0].type === "FunctionName";
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
/** @type {import('../shared/types').Rule} */
=======
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
=======
>>>>>>> bda8256cb (figuring out lint)
=======
/** @type {import('../shared/types').Rule} */
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> ee12506f5 (figuring out lint)
=======
/** @type {import('../shared/types').Rule} */
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> 84b8e337c (figuring out lint)
=======
=======
/** @type {import('../shared/types').Rule} */
=======
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
/** @type {import('../shared/types').Rule} */
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> 84b8e337c (figuring out lint)
>>>>>>> 5209f27ef (figuring out lint)
>>>>>>> bda8256cb (figuring out lint)
module.exports = {
    meta: {
        type: "suggestion",

        docs: {
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
=======
=======
>>>>>>> bda8256cb (figuring out lint)
            description: "Require or disallow named `function` expressions",
            recommended: false,
            url: "https://eslint.org/docs/latest/rules/func-names"
=======
=======
>>>>>>> 84b8e337c (figuring out lint)
<<<<<<< HEAD
=======
>>>>>>> ee12506f5 (figuring out lint)
=======
>>>>>>> 5209f27ef (figuring out lint)
>>>>>>> bda8256cb (figuring out lint)
            description: "require or disallow named `function` expressions",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/func-names"
<<<<<<< HEAD
<<<<<<< HEAD
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
=======
<<<<<<< HEAD
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
>>>>>>> 5209f27ef (figuring out lint)
=======
            description: "Require or disallow named `function` expressions",
            recommended: false,
            url: "https://eslint.org/docs/latest/rules/func-names"
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> bda8256cb (figuring out lint)
=======
            description: "Require or disallow named `function` expressions",
            recommended: false,
            url: "https://eslint.org/docs/latest/rules/func-names"
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> 84b8e337c (figuring out lint)
=======
=======
<<<<<<< HEAD
            description: "Require or disallow named `function` expressions",
            recommended: false,
            url: "https://eslint.org/docs/latest/rules/func-names"
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> ee12506f5 (figuring out lint)
=======
>>>>>>> 84b8e337c (figuring out lint)
>>>>>>> 5209f27ef (figuring out lint)
>>>>>>> bda8256cb (figuring out lint)
        },

        schema: {
            definitions: {
                value: {
                    enum: [
                        "always",
                        "as-needed",
                        "never"
                    ]
                }
            },
            items: [
                {
                    $ref: "#/definitions/value"
                },
                {
                    type: "object",
                    properties: {
                        generators: {
                            $ref: "#/definitions/value"
                        }
                    },
                    additionalProperties: false
                }
            ]
        },

        messages: {
            unnamed: "Unexpected unnamed {{name}}.",
            named: "Unexpected named {{name}}."
        }
    },

    create(context) {

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
        const sourceCode = context.sourceCode;
=======
        const sourceCode = context.getSourceCode();
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
>>>>>>> ee12506f5 (figuring out lint)
=======
>>>>>>> bda8256cb (figuring out lint)
        const sourceCode = context.getSourceCode();
=======
        const sourceCode = context.sourceCode;
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> 84b8e337c (figuring out lint)
=======
=======
        const sourceCode = context.sourceCode;
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> ee12506f5 (figuring out lint)
=======
=======
        const sourceCode = context.sourceCode;
=======
        const sourceCode = context.getSourceCode();
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
        const sourceCode = context.getSourceCode();
=======
        const sourceCode = context.sourceCode;
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> 84b8e337c (figuring out lint)
>>>>>>> 5209f27ef (figuring out lint)
>>>>>>> bda8256cb (figuring out lint)

        /**
         * Returns the config option for the given node.
         * @param {ASTNode} node A node to get the config for.
         * @returns {string} The config option.
         */
        function getConfigForNode(node) {
            if (
                node.generator &&
                context.options.length > 1 &&
                context.options[1].generators
            ) {
                return context.options[1].generators;
            }

            return context.options[0] || "always";
        }

        /**
         * Determines whether the current FunctionExpression node is a get, set, or
         * shorthand method in an object literal or a class.
         * @param {ASTNode} node A node to check.
         * @returns {boolean} True if the node is a get, set, or shorthand method.
         */
        function isObjectOrClassMethod(node) {
            const parent = node.parent;

            return (parent.type === "MethodDefinition" || (
                parent.type === "Property" && (
                    parent.method ||
                    parent.kind === "get" ||
                    parent.kind === "set"
                )
            ));
        }

        /**
         * Determines whether the current FunctionExpression node has a name that would be
         * inferred from context in a conforming ES6 environment.
         * @param {ASTNode} node A node to check.
         * @returns {boolean} True if the node would have a name assigned automatically.
         */
        function hasInferredName(node) {
            const parent = node.parent;

            return isObjectOrClassMethod(node) ||
                (parent.type === "VariableDeclarator" && parent.id.type === "Identifier" && parent.init === node) ||
                (parent.type === "Property" && parent.value === node) ||
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
                (parent.type === "PropertyDefinition" && parent.value === node) ||
                (parent.type === "AssignmentExpression" && parent.left.type === "Identifier" && parent.right === node) ||
                (parent.type === "AssignmentPattern" && parent.left.type === "Identifier" && parent.right === node);
=======
                (parent.type === "AssignmentExpression" && parent.left.type === "Identifier" && parent.right === node) ||
                (parent.type === "ExportDefaultDeclaration" && parent.declaration === node) ||
                (parent.type === "AssignmentPattern" && parent.right === node);
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
>>>>>>> ee12506f5 (figuring out lint)
=======
>>>>>>> bda8256cb (figuring out lint)
                (parent.type === "AssignmentExpression" && parent.left.type === "Identifier" && parent.right === node) ||
                (parent.type === "ExportDefaultDeclaration" && parent.declaration === node) ||
                (parent.type === "AssignmentPattern" && parent.right === node);
=======
                (parent.type === "PropertyDefinition" && parent.value === node) ||
                (parent.type === "AssignmentExpression" && parent.left.type === "Identifier" && parent.right === node) ||
                (parent.type === "AssignmentPattern" && parent.left.type === "Identifier" && parent.right === node);
<<<<<<< HEAD
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> 84b8e337c (figuring out lint)
=======
=======
=======
                (parent.type === "AssignmentExpression" && parent.left.type === "Identifier" && parent.right === node) ||
                (parent.type === "ExportDefaultDeclaration" && parent.declaration === node) ||
                (parent.type === "AssignmentPattern" && parent.right === node);
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
                (parent.type === "AssignmentExpression" && parent.left.type === "Identifier" && parent.right === node) ||
                (parent.type === "ExportDefaultDeclaration" && parent.declaration === node) ||
                (parent.type === "AssignmentPattern" && parent.right === node);
>>>>>>> 5209f27ef (figuring out lint)
>>>>>>> bda8256cb (figuring out lint)
=======
                (parent.type === "PropertyDefinition" && parent.value === node) ||
                (parent.type === "AssignmentExpression" && parent.left.type === "Identifier" && parent.right === node) ||
                (parent.type === "AssignmentPattern" && parent.left.type === "Identifier" && parent.right === node);
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> ee12506f5 (figuring out lint)
=======
<<<<<<< HEAD
=======
                (parent.type === "PropertyDefinition" && parent.value === node) ||
                (parent.type === "AssignmentExpression" && parent.left.type === "Identifier" && parent.right === node) ||
                (parent.type === "AssignmentPattern" && parent.left.type === "Identifier" && parent.right === node);
>>>>>>> 6be43a322 (figuring out lint)
=======
>>>>>>> 84b8e337c (figuring out lint)
>>>>>>> 5209f27ef (figuring out lint)
>>>>>>> bda8256cb (figuring out lint)
        }

        /**
         * Reports that an unnamed function should be named
         * @param {ASTNode} node The node to report in the event of an error.
         * @returns {void}
         */
        function reportUnexpectedUnnamedFunction(node) {
            context.report({
                node,
                messageId: "unnamed",
                loc: astUtils.getFunctionHeadLoc(node, sourceCode),
                data: { name: astUtils.getFunctionNameWithKind(node) }
            });
        }

        /**
         * Reports that a named function should be unnamed
         * @param {ASTNode} node The node to report in the event of an error.
         * @returns {void}
         */
        function reportUnexpectedNamedFunction(node) {
            context.report({
                node,
                messageId: "named",
                loc: astUtils.getFunctionHeadLoc(node, sourceCode),
                data: { name: astUtils.getFunctionNameWithKind(node) }
            });
        }

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
        /**
         * The listener for function nodes.
         * @param {ASTNode} node function node
         * @returns {void}
         */
        function handleFunction(node) {

            // Skip recursive functions.
            const nameVar = sourceCode.getDeclaredVariables(node)[0];

            if (isFunctionName(nameVar) && nameVar.references.length > 0) {
                return;
            }

            const hasName = Boolean(node.id && node.id.name);
            const config = getConfigForNode(node);

            if (config === "never") {
                if (hasName && node.type !== "FunctionDeclaration") {
                    reportUnexpectedNamedFunction(node);
                }
            } else if (config === "as-needed") {
                if (!hasName && !hasInferredName(node)) {
                    reportUnexpectedUnnamedFunction(node);
                }
            } else {
                if (!hasName && !isObjectOrClassMethod(node)) {
                    reportUnexpectedUnnamedFunction(node);
                }
            }
        }

        return {
            "FunctionExpression:exit": handleFunction,
            "ExportDefaultDeclaration > FunctionDeclaration": handleFunction
=======
=======
>>>>>>> 84b8e337c (figuring out lint)
=======
>>>>>>> ee12506f5 (figuring out lint)
=======
>>>>>>> bda8256cb (figuring out lint)
        return {
            "FunctionExpression:exit"(node) {

                // Skip recursive functions.
                const nameVar = context.getDeclaredVariables(node)[0];

                if (isFunctionName(nameVar) && nameVar.references.length > 0) {
                    return;
                }

                const hasName = Boolean(node.id && node.id.name);
                const config = getConfigForNode(node);

                if (config === "never") {
                    if (hasName) {
                        reportUnexpectedNamedFunction(node);
                    }
                } else if (config === "as-needed") {
                    if (!hasName && !hasInferredName(node)) {
                        reportUnexpectedUnnamedFunction(node);
                    }
                } else {
                    if (!hasName && !isObjectOrClassMethod(node)) {
                        reportUnexpectedUnnamedFunction(node);
                    }
                }
            }
<<<<<<< HEAD
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
=======
>>>>>>> 6be43a322 (figuring out lint)
=======
>>>>>>> 5209f27ef (figuring out lint)
        /**
         * The listener for function nodes.
         * @param {ASTNode} node function node
         * @returns {void}
         */
        function handleFunction(node) {

            // Skip recursive functions.
            const nameVar = sourceCode.getDeclaredVariables(node)[0];

            if (isFunctionName(nameVar) && nameVar.references.length > 0) {
                return;
            }

            const hasName = Boolean(node.id && node.id.name);
            const config = getConfigForNode(node);

            if (config === "never") {
                if (hasName && node.type !== "FunctionDeclaration") {
                    reportUnexpectedNamedFunction(node);
                }
            } else if (config === "as-needed") {
                if (!hasName && !hasInferredName(node)) {
                    reportUnexpectedUnnamedFunction(node);
                }
            } else {
                if (!hasName && !isObjectOrClassMethod(node)) {
                    reportUnexpectedUnnamedFunction(node);
                }
            }
        }

        return {
            "FunctionExpression:exit": handleFunction,
            "ExportDefaultDeclaration > FunctionDeclaration": handleFunction
<<<<<<< HEAD
>>>>>>> 6be43a322 (figuring out lint)
=======
<<<<<<< HEAD
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> 84b8e337c (figuring out lint)
=======
=======
=======
>>>>>>> 84b8e337c (figuring out lint)
        return {
            "FunctionExpression:exit"(node) {

                // Skip recursive functions.
                const nameVar = context.getDeclaredVariables(node)[0];

                if (isFunctionName(nameVar) && nameVar.references.length > 0) {
                    return;
                }

                const hasName = Boolean(node.id && node.id.name);
                const config = getConfigForNode(node);

                if (config === "never") {
                    if (hasName) {
                        reportUnexpectedNamedFunction(node);
                    }
                } else if (config === "as-needed") {
                    if (!hasName && !hasInferredName(node)) {
                        reportUnexpectedUnnamedFunction(node);
                    }
                } else {
                    if (!hasName && !isObjectOrClassMethod(node)) {
                        reportUnexpectedUnnamedFunction(node);
                    }
                }
            }
<<<<<<< HEAD
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
        /**
         * The listener for function nodes.
         * @param {ASTNode} node function node
         * @returns {void}
         */
        function handleFunction(node) {

            // Skip recursive functions.
            const nameVar = sourceCode.getDeclaredVariables(node)[0];

            if (isFunctionName(nameVar) && nameVar.references.length > 0) {
                return;
            }

            const hasName = Boolean(node.id && node.id.name);
            const config = getConfigForNode(node);

            if (config === "never") {
                if (hasName && node.type !== "FunctionDeclaration") {
                    reportUnexpectedNamedFunction(node);
                }
            } else if (config === "as-needed") {
                if (!hasName && !hasInferredName(node)) {
                    reportUnexpectedUnnamedFunction(node);
                }
            } else {
                if (!hasName && !isObjectOrClassMethod(node)) {
                    reportUnexpectedUnnamedFunction(node);
                }
            }
        }

        return {
            "FunctionExpression:exit": handleFunction,
            "ExportDefaultDeclaration > FunctionDeclaration": handleFunction
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> 84b8e337c (figuring out lint)
>>>>>>> 5209f27ef (figuring out lint)
>>>>>>> bda8256cb (figuring out lint)
        };
    }
};
