/**
 * @fileoverview Rule to disallow whitespace before properties
 * @author Kai Cataldo
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
 * @deprecated in ESLint v8.53.0
=======
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
=======
 * @deprecated in ESLint v8.53.0
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> ee12506f5 (figuring out lint)
=======
 * @deprecated in ESLint v8.53.0
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> 84b8e337c (figuring out lint)
 */
"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
/** @type {import('../shared/types').Rule} */
module.exports = {
    meta: {
        deprecated: true,
        replacedBy: [],
        type: "layout",

        docs: {
            description: "Disallow whitespace before properties",
            recommended: false,
            url: "https://eslint.org/docs/latest/rules/no-whitespace-before-property"
        },

        fixable: "whitespace",
        schema: [],

        messages: {
            unexpectedWhitespace: "Unexpected whitespace before property {{propName}}."
        }
    },

    create(context) {
        const sourceCode = context.sourceCode;
=======
=======
>>>>>>> 84b8e337c (figuring out lint)
=======
>>>>>>> ee12506f5 (figuring out lint)
module.exports = {
    meta: {
        type: "layout",

        docs: {
            description: "disallow whitespace before properties",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/no-whitespace-before-property"
        },

        fixable: "whitespace",
        schema: []
    },

    create(context) {
        const sourceCode = context.getSourceCode();
<<<<<<< HEAD
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
=======
>>>>>>> 6be43a322 (figuring out lint)
/** @type {import('../shared/types').Rule} */
module.exports = {
    meta: {
        deprecated: true,
        replacedBy: [],
        type: "layout",

        docs: {
            description: "Disallow whitespace before properties",
            recommended: false,
            url: "https://eslint.org/docs/latest/rules/no-whitespace-before-property"
        },

        fixable: "whitespace",
        schema: [],

        messages: {
            unexpectedWhitespace: "Unexpected whitespace before property {{propName}}."
        }
    },

    create(context) {
        const sourceCode = context.sourceCode;
<<<<<<< HEAD
>>>>>>> 6be43a322 (figuring out lint)
=======
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> 84b8e337c (figuring out lint)

        //--------------------------------------------------------------------------
        // Helpers
        //--------------------------------------------------------------------------

        /**
         * Reports whitespace before property token
         * @param {ASTNode} node the node to report in the event of an error
         * @param {Token} leftToken the left token
         * @param {Token} rightToken the right token
         * @returns {void}
         * @private
         */
        function reportError(node, leftToken, rightToken) {
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
            context.report({
                node,
                messageId: "unexpectedWhitespace",
=======
=======
>>>>>>> 84b8e337c (figuring out lint)
=======
>>>>>>> ee12506f5 (figuring out lint)
            const replacementText = node.computed ? "" : ".";

            context.report({
                node,
                message: "Unexpected whitespace before property {{propName}}.",
<<<<<<< HEAD
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
            context.report({
                node,
                messageId: "unexpectedWhitespace",
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> 84b8e337c (figuring out lint)
=======
=======
            context.report({
                node,
                messageId: "unexpectedWhitespace",
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> ee12506f5 (figuring out lint)
                data: {
                    propName: sourceCode.getText(node.property)
                },
                fix(fixer) {
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
                    let replacementText = "";

                    if (!node.computed && !node.optional && astUtils.isDecimalInteger(node.object)) {
=======
                    if (!node.computed && astUtils.isDecimalInteger(node.object)) {
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
>>>>>>> ee12506f5 (figuring out lint)
                    if (!node.computed && astUtils.isDecimalInteger(node.object)) {
=======
                    let replacementText = "";

                    if (!node.computed && !node.optional && astUtils.isDecimalInteger(node.object)) {
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> 84b8e337c (figuring out lint)
=======
=======
                    let replacementText = "";

                    if (!node.computed && !node.optional && astUtils.isDecimalInteger(node.object)) {
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> ee12506f5 (figuring out lint)

                        /*
                         * If the object is a number literal, fixing it to something like 5.toString() would cause a SyntaxError.
                         * Don't fix this case.
                         */
                        return null;
                    }
<<<<<<< HEAD
<<<<<<< HEAD
=======
=======
<<<<<<< HEAD
>>>>>>> 84b8e337c (figuring out lint)
=======
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> ee12506f5 (figuring out lint)

                    // Don't fix if comments exist.
                    if (sourceCode.commentsExistBetween(leftToken, rightToken)) {
                        return null;
                    }

                    if (node.optional) {
                        replacementText = "?.";
                    } else if (!node.computed) {
                        replacementText = ".";
                    }

<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> ee12506f5 (figuring out lint)
=======
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> 84b8e337c (figuring out lint)
                    return fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], replacementText);
                }
            });
        }

        //--------------------------------------------------------------------------
        // Public
        //--------------------------------------------------------------------------

        return {
            MemberExpression(node) {
                let rightToken;
                let leftToken;

                if (!astUtils.isTokenOnSameLine(node.object, node.property)) {
                    return;
                }

                if (node.computed) {
                    rightToken = sourceCode.getTokenBefore(node.property, astUtils.isOpeningBracketToken);
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
                    leftToken = sourceCode.getTokenBefore(rightToken, node.optional ? 1 : 0);
=======
                    leftToken = sourceCode.getTokenBefore(rightToken);
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
>>>>>>> ee12506f5 (figuring out lint)
                    leftToken = sourceCode.getTokenBefore(rightToken);
=======
                    leftToken = sourceCode.getTokenBefore(rightToken, node.optional ? 1 : 0);
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> 84b8e337c (figuring out lint)
=======
=======
                    leftToken = sourceCode.getTokenBefore(rightToken, node.optional ? 1 : 0);
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> ee12506f5 (figuring out lint)
                } else {
                    rightToken = sourceCode.getFirstToken(node.property);
                    leftToken = sourceCode.getTokenBefore(rightToken, 1);
                }

                if (sourceCode.isSpaceBetweenTokens(leftToken, rightToken)) {
                    reportError(node, leftToken, rightToken);
                }
            }
        };
    }
};
