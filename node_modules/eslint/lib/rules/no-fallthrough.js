/**
 * @fileoverview Rule to flag fall-through cases in switch statements.
 * @author Matt DuVall <http://mattduvall.com/>
 */
"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
const { directivesPattern } = require("../shared/directives");
=======
const lodash = require("lodash");
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
>>>>>>> ee12506f5 (figuring out lint)
=======
>>>>>>> bda8256cb (figuring out lint)
const lodash = require("lodash");
=======
const { directivesPattern } = require("../shared/directives");
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> 84b8e337c (figuring out lint)
=======
=======
const { directivesPattern } = require("../shared/directives");
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> ee12506f5 (figuring out lint)
=======
=======
const { directivesPattern } = require("../shared/directives");
=======
const lodash = require("lodash");
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
const lodash = require("lodash");
=======
const { directivesPattern } = require("../shared/directives");
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> 84b8e337c (figuring out lint)
>>>>>>> 5209f27ef (figuring out lint)
>>>>>>> bda8256cb (figuring out lint)

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const DEFAULT_FALLTHROUGH_COMMENT = /falls?\s?through/iu;

/**
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
 * Checks all segments in a set and returns true if any are reachable.
 * @param {Set<CodePathSegment>} segments The segments to check.
 * @returns {boolean} True if any segment is reachable; false otherwise.
 */
function isAnySegmentReachable(segments) {

    for (const segment of segments) {
        if (segment.reachable) {
            return true;
        }
    }

    return false;
}

/**
 * Checks whether or not a given comment string is really a fallthrough comment and not an ESLint directive.
 * @param {string} comment The comment string to check.
 * @param {RegExp} fallthroughCommentPattern The regular expression used for checking for fallthrough comments.
 * @returns {boolean} `true` if the comment string is truly a fallthrough comment.
 */
function isFallThroughComment(comment, fallthroughCommentPattern) {
    return fallthroughCommentPattern.test(comment) && !directivesPattern.test(comment.trim());
}

/**
 * Checks whether or not a given case has a fallthrough comment.
 * @param {ASTNode} caseWhichFallsThrough SwitchCase node which falls through.
 * @param {ASTNode} subsequentCase The case after caseWhichFallsThrough.
 * @param {RuleContext} context A rule context which stores comments.
 * @param {RegExp} fallthroughCommentPattern A pattern to match comment to.
 * @returns {boolean} `true` if the case has a valid fallthrough comment.
 */
function hasFallthroughComment(caseWhichFallsThrough, subsequentCase, context, fallthroughCommentPattern) {
    const sourceCode = context.sourceCode;

    if (caseWhichFallsThrough.consequent.length === 1 && caseWhichFallsThrough.consequent[0].type === "BlockStatement") {
        const trailingCloseBrace = sourceCode.getLastToken(caseWhichFallsThrough.consequent[0]);
        const commentInBlock = sourceCode.getCommentsBefore(trailingCloseBrace).pop();

        if (commentInBlock && isFallThroughComment(commentInBlock.value, fallthroughCommentPattern)) {
            return true;
        }
    }

    const comment = sourceCode.getCommentsBefore(subsequentCase).pop();

    return Boolean(comment && isFallThroughComment(comment.value, fallthroughCommentPattern));
=======
=======
>>>>>>> 84b8e337c (figuring out lint)
=======
>>>>>>> ee12506f5 (figuring out lint)
=======
>>>>>>> bda8256cb (figuring out lint)
 * Checks whether or not a given node has a fallthrough comment.
 * @param {ASTNode} node A SwitchCase node to get comments.
 * @param {RuleContext} context A rule context which stores comments.
 * @param {RegExp} fallthroughCommentPattern A pattern to match comment to.
 * @returns {boolean} `true` if the node has a valid fallthrough comment.
 */
function hasFallthroughComment(node, context, fallthroughCommentPattern) {
    const sourceCode = context.getSourceCode();
    const comment = lodash.last(sourceCode.getCommentsBefore(node));

    return Boolean(comment && fallthroughCommentPattern.test(comment.value));
}

/**
 * Checks whether or not a given code path segment is reachable.
 * @param {CodePathSegment} segment A CodePathSegment to check.
 * @returns {boolean} `true` if the segment is reachable.
 */
function isReachable(segment) {
    return segment.reachable;
<<<<<<< HEAD
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
=======
>>>>>>> 6be43a322 (figuring out lint)
=======
>>>>>>> 5209f27ef (figuring out lint)
 * Checks all segments in a set and returns true if any are reachable.
 * @param {Set<CodePathSegment>} segments The segments to check.
 * @returns {boolean} True if any segment is reachable; false otherwise.
 */
function isAnySegmentReachable(segments) {

    for (const segment of segments) {
        if (segment.reachable) {
            return true;
        }
    }

    return false;
}

/**
 * Checks whether or not a given comment string is really a fallthrough comment and not an ESLint directive.
 * @param {string} comment The comment string to check.
 * @param {RegExp} fallthroughCommentPattern The regular expression used for checking for fallthrough comments.
 * @returns {boolean} `true` if the comment string is truly a fallthrough comment.
 */
function isFallThroughComment(comment, fallthroughCommentPattern) {
    return fallthroughCommentPattern.test(comment) && !directivesPattern.test(comment.trim());
}

/**
 * Checks whether or not a given case has a fallthrough comment.
 * @param {ASTNode} caseWhichFallsThrough SwitchCase node which falls through.
 * @param {ASTNode} subsequentCase The case after caseWhichFallsThrough.
 * @param {RuleContext} context A rule context which stores comments.
 * @param {RegExp} fallthroughCommentPattern A pattern to match comment to.
 * @returns {boolean} `true` if the case has a valid fallthrough comment.
 */
function hasFallthroughComment(caseWhichFallsThrough, subsequentCase, context, fallthroughCommentPattern) {
    const sourceCode = context.sourceCode;

    if (caseWhichFallsThrough.consequent.length === 1 && caseWhichFallsThrough.consequent[0].type === "BlockStatement") {
        const trailingCloseBrace = sourceCode.getLastToken(caseWhichFallsThrough.consequent[0]);
        const commentInBlock = sourceCode.getCommentsBefore(trailingCloseBrace).pop();

        if (commentInBlock && isFallThroughComment(commentInBlock.value, fallthroughCommentPattern)) {
            return true;
        }
    }

    const comment = sourceCode.getCommentsBefore(subsequentCase).pop();

    return Boolean(comment && isFallThroughComment(comment.value, fallthroughCommentPattern));
<<<<<<< HEAD
>>>>>>> 6be43a322 (figuring out lint)
=======
<<<<<<< HEAD
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> 84b8e337c (figuring out lint)
=======
=======
=======
>>>>>>> 84b8e337c (figuring out lint)
 * Checks whether or not a given node has a fallthrough comment.
 * @param {ASTNode} node A SwitchCase node to get comments.
 * @param {RuleContext} context A rule context which stores comments.
 * @param {RegExp} fallthroughCommentPattern A pattern to match comment to.
 * @returns {boolean} `true` if the node has a valid fallthrough comment.
 */
function hasFallthroughComment(node, context, fallthroughCommentPattern) {
    const sourceCode = context.getSourceCode();
    const comment = lodash.last(sourceCode.getCommentsBefore(node));

    return Boolean(comment && fallthroughCommentPattern.test(comment.value));
}

/**
 * Checks whether or not a given code path segment is reachable.
 * @param {CodePathSegment} segment A CodePathSegment to check.
 * @returns {boolean} `true` if the segment is reachable.
 */
function isReachable(segment) {
    return segment.reachable;
<<<<<<< HEAD
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
 * Checks all segments in a set and returns true if any are reachable.
 * @param {Set<CodePathSegment>} segments The segments to check.
 * @returns {boolean} True if any segment is reachable; false otherwise.
 */
function isAnySegmentReachable(segments) {

    for (const segment of segments) {
        if (segment.reachable) {
            return true;
        }
    }

    return false;
}

/**
 * Checks whether or not a given comment string is really a fallthrough comment and not an ESLint directive.
 * @param {string} comment The comment string to check.
 * @param {RegExp} fallthroughCommentPattern The regular expression used for checking for fallthrough comments.
 * @returns {boolean} `true` if the comment string is truly a fallthrough comment.
 */
function isFallThroughComment(comment, fallthroughCommentPattern) {
    return fallthroughCommentPattern.test(comment) && !directivesPattern.test(comment.trim());
}

/**
 * Checks whether or not a given case has a fallthrough comment.
 * @param {ASTNode} caseWhichFallsThrough SwitchCase node which falls through.
 * @param {ASTNode} subsequentCase The case after caseWhichFallsThrough.
 * @param {RuleContext} context A rule context which stores comments.
 * @param {RegExp} fallthroughCommentPattern A pattern to match comment to.
 * @returns {boolean} `true` if the case has a valid fallthrough comment.
 */
function hasFallthroughComment(caseWhichFallsThrough, subsequentCase, context, fallthroughCommentPattern) {
    const sourceCode = context.sourceCode;

    if (caseWhichFallsThrough.consequent.length === 1 && caseWhichFallsThrough.consequent[0].type === "BlockStatement") {
        const trailingCloseBrace = sourceCode.getLastToken(caseWhichFallsThrough.consequent[0]);
        const commentInBlock = sourceCode.getCommentsBefore(trailingCloseBrace).pop();

        if (commentInBlock && isFallThroughComment(commentInBlock.value, fallthroughCommentPattern)) {
            return true;
        }
    }

    const comment = sourceCode.getCommentsBefore(subsequentCase).pop();

    return Boolean(comment && isFallThroughComment(comment.value, fallthroughCommentPattern));
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> 84b8e337c (figuring out lint)
>>>>>>> 5209f27ef (figuring out lint)
>>>>>>> bda8256cb (figuring out lint)
}

/**
 * Checks whether a node and a token are separated by blank lines
 * @param {ASTNode} node The node to check
 * @param {Token} token The token to compare against
 * @returns {boolean} `true` if there are blank lines between node and token
 */
function hasBlankLinesBetween(node, token) {
    return token.loc.start.line > node.loc.end.line + 1;
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
/** @type {import('../shared/types').Rule} */
=======
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
=======
>>>>>>> bda8256cb (figuring out lint)
=======
/** @type {import('../shared/types').Rule} */
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> ee12506f5 (figuring out lint)
=======
/** @type {import('../shared/types').Rule} */
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> 84b8e337c (figuring out lint)
=======
=======
/** @type {import('../shared/types').Rule} */
=======
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
/** @type {import('../shared/types').Rule} */
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> 84b8e337c (figuring out lint)
>>>>>>> 5209f27ef (figuring out lint)
>>>>>>> bda8256cb (figuring out lint)
module.exports = {
    meta: {
        type: "problem",

        docs: {
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
=======
=======
>>>>>>> bda8256cb (figuring out lint)
            description: "Disallow fallthrough of `case` statements",
            recommended: true,
            url: "https://eslint.org/docs/latest/rules/no-fallthrough"
=======
=======
>>>>>>> 84b8e337c (figuring out lint)
<<<<<<< HEAD
=======
>>>>>>> ee12506f5 (figuring out lint)
=======
>>>>>>> 5209f27ef (figuring out lint)
>>>>>>> bda8256cb (figuring out lint)
            description: "disallow fallthrough of `case` statements",
            category: "Best Practices",
            recommended: true,
            url: "https://eslint.org/docs/rules/no-fallthrough"
<<<<<<< HEAD
<<<<<<< HEAD
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
=======
<<<<<<< HEAD
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
>>>>>>> 5209f27ef (figuring out lint)
=======
            description: "Disallow fallthrough of `case` statements",
            recommended: true,
            url: "https://eslint.org/docs/latest/rules/no-fallthrough"
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> bda8256cb (figuring out lint)
=======
            description: "Disallow fallthrough of `case` statements",
            recommended: true,
            url: "https://eslint.org/docs/latest/rules/no-fallthrough"
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> 84b8e337c (figuring out lint)
=======
=======
<<<<<<< HEAD
            description: "Disallow fallthrough of `case` statements",
            recommended: true,
            url: "https://eslint.org/docs/latest/rules/no-fallthrough"
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> ee12506f5 (figuring out lint)
=======
>>>>>>> 84b8e337c (figuring out lint)
>>>>>>> 5209f27ef (figuring out lint)
>>>>>>> bda8256cb (figuring out lint)
        },

        schema: [
            {
                type: "object",
                properties: {
                    commentPattern: {
                        type: "string",
                        default: ""
<<<<<<< HEAD
<<<<<<< HEAD
=======
=======
<<<<<<< HEAD
<<<<<<< HEAD
>>>>>>> 84b8e337c (figuring out lint)
=======
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> ee12506f5 (figuring out lint)
=======
>>>>>>> 6be43a322 (figuring out lint)
=======
>>>>>>> 84b8e337c (figuring out lint)
>>>>>>> 5209f27ef (figuring out lint)
>>>>>>> bda8256cb (figuring out lint)
                    },
                    allowEmptyCase: {
                        type: "boolean",
                        default: false
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> ee12506f5 (figuring out lint)
=======
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> 84b8e337c (figuring out lint)
=======
>>>>>>> 6be43a322 (figuring out lint)
=======
>>>>>>> 6be43a322 (figuring out lint)
=======
=======
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> 84b8e337c (figuring out lint)
>>>>>>> 5209f27ef (figuring out lint)
>>>>>>> bda8256cb (figuring out lint)
                    }
                },
                additionalProperties: false
            }
        ],
        messages: {
            case: "Expected a 'break' statement before 'case'.",
            default: "Expected a 'break' statement before 'default'."
        }
    },

    create(context) {
        const options = context.options[0] || {};
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
        const codePathSegments = [];
        let currentCodePathSegments = new Set();
        const sourceCode = context.sourceCode;
        const allowEmptyCase = options.allowEmptyCase || false;
=======
        let currentCodePath = null;
        const sourceCode = context.getSourceCode();
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
>>>>>>> ee12506f5 (figuring out lint)
=======
>>>>>>> bda8256cb (figuring out lint)
        let currentCodePath = null;
        const sourceCode = context.getSourceCode();
=======
=======
>>>>>>> 6be43a322 (figuring out lint)
=======
>>>>>>> 5209f27ef (figuring out lint)
        const codePathSegments = [];
        let currentCodePathSegments = new Set();
        const sourceCode = context.sourceCode;
        const allowEmptyCase = options.allowEmptyCase || false;
<<<<<<< HEAD
>>>>>>> 6be43a322 (figuring out lint)
=======
<<<<<<< HEAD
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> 84b8e337c (figuring out lint)
=======
=======
        let currentCodePath = null;
        const sourceCode = context.getSourceCode();
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
        let currentCodePath = null;
        const sourceCode = context.getSourceCode();
=======
        const codePathSegments = [];
        let currentCodePathSegments = new Set();
        const sourceCode = context.sourceCode;
        const allowEmptyCase = options.allowEmptyCase || false;
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> 84b8e337c (figuring out lint)
>>>>>>> 5209f27ef (figuring out lint)
>>>>>>> bda8256cb (figuring out lint)

        /*
         * We need to use leading comments of the next SwitchCase node because
         * trailing comments is wrong if semicolons are omitted.
         */
        let fallthroughCase = null;
        let fallthroughCommentPattern = null;

        if (options.commentPattern) {
            fallthroughCommentPattern = new RegExp(options.commentPattern, "u");
        } else {
            fallthroughCommentPattern = DEFAULT_FALLTHROUGH_COMMENT;
        }
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
        return {

            onCodePathStart() {
                codePathSegments.push(currentCodePathSegments);
                currentCodePathSegments = new Set();
            },

            onCodePathEnd() {
                currentCodePathSegments = codePathSegments.pop();
            },

            onUnreachableCodePathSegmentStart(segment) {
                currentCodePathSegments.add(segment);
            },

            onUnreachableCodePathSegmentEnd(segment) {
                currentCodePathSegments.delete(segment);
            },

            onCodePathSegmentStart(segment) {
                currentCodePathSegments.add(segment);
            },

            onCodePathSegmentEnd(segment) {
                currentCodePathSegments.delete(segment);
            },


=======
=======
>>>>>>> 84b8e337c (figuring out lint)
=======
>>>>>>> ee12506f5 (figuring out lint)
=======
>>>>>>> bda8256cb (figuring out lint)

        return {
            onCodePathStart(codePath) {
                currentCodePath = codePath;
            },
            onCodePathEnd() {
                currentCodePath = currentCodePath.upper;
            },

<<<<<<< HEAD
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
=======
>>>>>>> 6be43a322 (figuring out lint)
=======
>>>>>>> 5209f27ef (figuring out lint)
        return {

            onCodePathStart() {
                codePathSegments.push(currentCodePathSegments);
                currentCodePathSegments = new Set();
            },

            onCodePathEnd() {
                currentCodePathSegments = codePathSegments.pop();
            },

            onUnreachableCodePathSegmentStart(segment) {
                currentCodePathSegments.add(segment);
            },

            onUnreachableCodePathSegmentEnd(segment) {
                currentCodePathSegments.delete(segment);
            },

            onCodePathSegmentStart(segment) {
                currentCodePathSegments.add(segment);
            },

            onCodePathSegmentEnd(segment) {
                currentCodePathSegments.delete(segment);
            },


<<<<<<< HEAD
>>>>>>> 6be43a322 (figuring out lint)
=======
<<<<<<< HEAD
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> 84b8e337c (figuring out lint)
=======
=======
=======
>>>>>>> 84b8e337c (figuring out lint)

        return {
            onCodePathStart(codePath) {
                currentCodePath = codePath;
            },
            onCodePathEnd() {
                currentCodePath = currentCodePath.upper;
            },

<<<<<<< HEAD
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
        return {

            onCodePathStart() {
                codePathSegments.push(currentCodePathSegments);
                currentCodePathSegments = new Set();
            },

            onCodePathEnd() {
                currentCodePathSegments = codePathSegments.pop();
            },

            onUnreachableCodePathSegmentStart(segment) {
                currentCodePathSegments.add(segment);
            },

            onUnreachableCodePathSegmentEnd(segment) {
                currentCodePathSegments.delete(segment);
            },

            onCodePathSegmentStart(segment) {
                currentCodePathSegments.add(segment);
            },

            onCodePathSegmentEnd(segment) {
                currentCodePathSegments.delete(segment);
            },


>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> 84b8e337c (figuring out lint)
>>>>>>> 5209f27ef (figuring out lint)
>>>>>>> bda8256cb (figuring out lint)
            SwitchCase(node) {

                /*
                 * Checks whether or not there is a fallthrough comment.
                 * And reports the previous fallthrough node if that does not exist.
                 */
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD

                if (fallthroughCase && (!hasFallthroughComment(fallthroughCase, node, context, fallthroughCommentPattern))) {
=======
                if (fallthroughCase && !hasFallthroughComment(node, context, fallthroughCommentPattern)) {
=======
=======
>>>>>>> 5209f27ef (figuring out lint)

                if (fallthroughCase && (!hasFallthroughComment(fallthroughCase, node, context, fallthroughCommentPattern))) {
>>>>>>> 6be43a322 (figuring out lint)
=======
<<<<<<< HEAD

                if (fallthroughCase && (!hasFallthroughComment(fallthroughCase, node, context, fallthroughCommentPattern))) {
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> bda8256cb (figuring out lint)
=======
                if (fallthroughCase && !hasFallthroughComment(node, context, fallthroughCommentPattern)) {
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
<<<<<<< HEAD
=======
>>>>>>> ee12506f5 (figuring out lint)
=======
>>>>>>> bda8256cb (figuring out lint)
                if (fallthroughCase && !hasFallthroughComment(node, context, fallthroughCommentPattern)) {
=======

                if (fallthroughCase && (!hasFallthroughComment(fallthroughCase, node, context, fallthroughCommentPattern))) {
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
<<<<<<< HEAD
>>>>>>> 84b8e337c (figuring out lint)
=======
=======

                if (fallthroughCase && (!hasFallthroughComment(fallthroughCase, node, context, fallthroughCommentPattern))) {
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> ee12506f5 (figuring out lint)
=======
>>>>>>> 84b8e337c (figuring out lint)
>>>>>>> 5209f27ef (figuring out lint)
>>>>>>> bda8256cb (figuring out lint)
                    context.report({
                        messageId: node.test ? "case" : "default",
                        node
                    });
                }
                fallthroughCase = null;
            },

            "SwitchCase:exit"(node) {
                const nextToken = sourceCode.getTokenAfter(node);

                /*
                 * `reachable` meant fall through because statements preceded by
                 * `break`, `return`, or `throw` are unreachable.
                 * And allows empty cases and the last case.
                 */
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
                if (isAnySegmentReachable(currentCodePathSegments) &&
                    (node.consequent.length > 0 || (!allowEmptyCase && hasBlankLinesBetween(node, nextToken))) &&
                    node.parent.cases[node.parent.cases.length - 1] !== node) {
=======
                if (currentCodePath.currentSegments.some(isReachable) &&
                    (node.consequent.length > 0 || hasBlankLinesBetween(node, nextToken)) &&
                    lodash.last(node.parent.cases) !== node) {
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
>>>>>>> ee12506f5 (figuring out lint)
=======
>>>>>>> bda8256cb (figuring out lint)
                if (currentCodePath.currentSegments.some(isReachable) &&
                    (node.consequent.length > 0 || hasBlankLinesBetween(node, nextToken)) &&
                    lodash.last(node.parent.cases) !== node) {
=======
                if (isAnySegmentReachable(currentCodePathSegments) &&
                    (node.consequent.length > 0 || (!allowEmptyCase && hasBlankLinesBetween(node, nextToken))) &&
                    node.parent.cases[node.parent.cases.length - 1] !== node) {
<<<<<<< HEAD
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> 84b8e337c (figuring out lint)
=======
=======
=======
                if (currentCodePath.currentSegments.some(isReachable) &&
                    (node.consequent.length > 0 || hasBlankLinesBetween(node, nextToken)) &&
                    lodash.last(node.parent.cases) !== node) {
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
                if (currentCodePath.currentSegments.some(isReachable) &&
                    (node.consequent.length > 0 || hasBlankLinesBetween(node, nextToken)) &&
                    lodash.last(node.parent.cases) !== node) {
>>>>>>> 5209f27ef (figuring out lint)
>>>>>>> bda8256cb (figuring out lint)
=======
                if (isAnySegmentReachable(currentCodePathSegments) &&
                    (node.consequent.length > 0 || (!allowEmptyCase && hasBlankLinesBetween(node, nextToken))) &&
                    node.parent.cases[node.parent.cases.length - 1] !== node) {
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> ee12506f5 (figuring out lint)
=======
<<<<<<< HEAD
=======
                if (isAnySegmentReachable(currentCodePathSegments) &&
                    (node.consequent.length > 0 || (!allowEmptyCase && hasBlankLinesBetween(node, nextToken))) &&
                    node.parent.cases[node.parent.cases.length - 1] !== node) {
>>>>>>> 6be43a322 (figuring out lint)
=======
>>>>>>> 84b8e337c (figuring out lint)
>>>>>>> 5209f27ef (figuring out lint)
>>>>>>> bda8256cb (figuring out lint)
                    fallthroughCase = node;
                }
            }
        };
    }
};
