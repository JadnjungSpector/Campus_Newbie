/**
 * @fileoverview Enforce spacing between rest and spread operators and their expressions.
 * @author Kai Cataldo
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
 * @deprecated in ESLint v8.53.0
=======
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
=======
 * @deprecated in ESLint v8.53.0
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> ee12506f5 (figuring out lint)
=======
 * @deprecated in ESLint v8.53.0
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> 84b8e337c (figuring out lint)
 */

"use strict";

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
/** @type {import('../shared/types').Rule} */
module.exports = {
    meta: {
        deprecated: true,
        replacedBy: [],
        type: "layout",

        docs: {
            description: "Enforce spacing between rest and spread operators and their expressions",
            recommended: false,
            url: "https://eslint.org/docs/latest/rules/rest-spread-spacing"
=======
=======
>>>>>>> 84b8e337c (figuring out lint)
=======
>>>>>>> ee12506f5 (figuring out lint)
module.exports = {
    meta: {
        type: "layout",

        docs: {
            description: "enforce spacing between rest and spread operators and their expressions",
            category: "ECMAScript 6",
            recommended: false,
            url: "https://eslint.org/docs/rules/rest-spread-spacing"
<<<<<<< HEAD
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
=======
>>>>>>> 6be43a322 (figuring out lint)
/** @type {import('../shared/types').Rule} */
module.exports = {
    meta: {
        deprecated: true,
        replacedBy: [],
        type: "layout",

        docs: {
            description: "Enforce spacing between rest and spread operators and their expressions",
            recommended: false,
            url: "https://eslint.org/docs/latest/rules/rest-spread-spacing"
<<<<<<< HEAD
>>>>>>> 6be43a322 (figuring out lint)
=======
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> 84b8e337c (figuring out lint)
        },

        fixable: "whitespace",

        schema: [
            {
                enum: ["always", "never"]
            }
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
        ],

        messages: {
            unexpectedWhitespace: "Unexpected whitespace after {{type}} operator.",
            expectedWhitespace: "Expected whitespace after {{type}} operator."
        }
    },

    create(context) {
        const sourceCode = context.sourceCode,
=======
=======
>>>>>>> 84b8e337c (figuring out lint)
=======
>>>>>>> ee12506f5 (figuring out lint)
        ]
    },

    create(context) {
        const sourceCode = context.getSourceCode(),
<<<<<<< HEAD
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
=======
>>>>>>> 6be43a322 (figuring out lint)
        ],

        messages: {
            unexpectedWhitespace: "Unexpected whitespace after {{type}} operator.",
            expectedWhitespace: "Expected whitespace after {{type}} operator."
        }
    },

    create(context) {
        const sourceCode = context.sourceCode,
<<<<<<< HEAD
>>>>>>> 6be43a322 (figuring out lint)
=======
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> 84b8e337c (figuring out lint)
            alwaysSpace = context.options[0] === "always";

        //--------------------------------------------------------------------------
        // Helpers
        //--------------------------------------------------------------------------

        /**
         * Checks whitespace between rest/spread operators and their expressions
         * @param {ASTNode} node The node to check
         * @returns {void}
         */
        function checkWhiteSpace(node) {
            const operator = sourceCode.getFirstToken(node),
                nextToken = sourceCode.getTokenAfter(operator),
                hasWhitespace = sourceCode.isSpaceBetweenTokens(operator, nextToken);
            let type;

            switch (node.type) {
                case "SpreadElement":
                    type = "spread";
                    if (node.parent.type === "ObjectExpression") {
                        type += " property";
                    }
                    break;
                case "RestElement":
                    type = "rest";
                    if (node.parent.type === "ObjectPattern") {
                        type += " property";
                    }
                    break;
                case "ExperimentalSpreadProperty":
                    type = "spread property";
                    break;
                case "ExperimentalRestProperty":
                    type = "rest property";
                    break;
                default:
                    return;
            }

            if (alwaysSpace && !hasWhitespace) {
                context.report({
                    node,
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
                    loc: operator.loc,
                    messageId: "expectedWhitespace",
=======
=======
>>>>>>> 84b8e337c (figuring out lint)
=======
>>>>>>> ee12506f5 (figuring out lint)
                    loc: {
                        line: operator.loc.end.line,
                        column: operator.loc.end.column
                    },
                    message: "Expected whitespace after {{type}} operator.",
<<<<<<< HEAD
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
                    loc: operator.loc,
                    messageId: "expectedWhitespace",
>>>>>>> 6be43a322 (figuring out lint)
<<<<<<< HEAD
>>>>>>> 84b8e337c (figuring out lint)
=======
=======
                    loc: operator.loc,
                    messageId: "expectedWhitespace",
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> ee12506f5 (figuring out lint)
                    data: {
                        type
                    },
                    fix(fixer) {
                        return fixer.replaceTextRange([operator.range[1], nextToken.range[0]], " ");
                    }
                });
            } else if (!alwaysSpace && hasWhitespace) {
                context.report({
                    node,
                    loc: {
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
                        start: operator.loc.end,
                        end: nextToken.loc.start
                    },
                    messageId: "unexpectedWhitespace",
=======
=======
>>>>>>> 84b8e337c (figuring out lint)
=======
>>>>>>> ee12506f5 (figuring out lint)
                        line: operator.loc.end.line,
                        column: operator.loc.end.column
                    },
                    message: "Unexpected whitespace after {{type}} operator.",
<<<<<<< HEAD
>>>>>>> cbaeadb69664be713d49558df22b6f02c48f3384
=======
=======
=======
>>>>>>> 6be43a322 (figuring out lint)
                        start: operator.loc.end,
                        end: nextToken.loc.start
                    },
                    messageId: "unexpectedWhitespace",
<<<<<<< HEAD
>>>>>>> 6be43a322 (figuring out lint)
=======
>>>>>>> 6be43a322 (figuring out lint)
>>>>>>> 84b8e337c (figuring out lint)
                    data: {
                        type
                    },
                    fix(fixer) {
                        return fixer.removeRange([operator.range[1], nextToken.range[0]]);
                    }
                });
            }
        }

        //--------------------------------------------------------------------------
        // Public
        //--------------------------------------------------------------------------

        return {
            SpreadElement: checkWhiteSpace,
            RestElement: checkWhiteSpace,
            ExperimentalSpreadProperty: checkWhiteSpace,
            ExperimentalRestProperty: checkWhiteSpace
        };
    }
};
